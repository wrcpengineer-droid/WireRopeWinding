<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wire Rope Factory - Integrated Tag Distribution</title>
<style>
  body, html { margin: 0; padding: 0; height: 100%; font-family: Arial, sans-serif; background-color: #f8faff; color: #1a2a6c; }
  #app { display: flex; height: 100vh; }
  #leftPanel { flex: 0 0 450px; background-color: #203a96; color: white; padding: 20px; display: flex; flex-direction: column; overflow-y: auto; }
  #leftPanel h2 { margin-top: 0; margin-bottom: 16px; font-weight: 600; user-select: none; }
  label { margin-top: 10px; margin-bottom: 6px; font-weight: bold; display: block; }
  input[type=text], input[type=number], select { width: 100%; padding: 7px; border-radius: 4px; border: none; font-size: 14px; }
  input[readonly] { background-color: #e3ebff; border: 1px solid #304486; font-weight: bold; }
  .toggleSwitch { position: relative; display: inline-block; width: 46px; height: 24px; margin-left: 6px; vertical-align: middle; }
  .toggleSwitch input { opacity: 0; width: 0; height: 0; }
  .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
  .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
  input:checked + .slider { background-color: #4CAF50; }
  input:checked + .slider:before { transform: translateX(22px); }
  button { margin-top: 10px; padding: 12px; background: #3a54d1; border: none; color: white; font-weight: bold; font-size: 15px; border-radius: 6px; cursor: pointer; transition: background-color 0.3s ease; user-select: none; }
  button:hover:not(:disabled) { background-color: #506fc5; }
  button:disabled { background-color: #8593de; cursor: not-allowed; }
  #tagTable, #processedTable { margin-top: 15px; border-collapse: collapse; width: 100%; background: white; color: #1a2a6c; font-size: 13px; }
  #tagTable th, #tagTable td, #processedTable th, #processedTable td { border: 1px solid #405da5; padding: 6px 8px; text-align: center; }
  #tagTable th, #processedTable th { background-color: #304486; color: white; }
  #modalContent table#queueTableModal { border: 2px solid #3a54d1; border-collapse: collapse; margin-bottom: 10px; }
  #modalContent table#queueTableModal th, #modalContent table#queueTableModal td { border: 1px solid #3a54d1; padding: 5px; text-align: center; }
  #mainPanel { flex-grow: 1; padding: 30px; background: #e3ebff; display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; align-content: flex-start; }
  .machineBlock { width: 120px; height: 120px; border-radius: 10px; box-shadow: 0 3px 8px rgba(58, 84, 209, 0.40); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; cursor: pointer; user-select: none; transition: background-color 0.3s ease; position: relative; font-weight: 700; }
  .machineBlock.green { background-color: #4caf50; }
  .machineBlock.orange { background-color: #ff9800; }
  .machineBlock.red { background-color: #f44336; }
  .machineTitle { font-size: 18px; }
  .tagCount { font-size: 34px; margin-top: 8px; letter-spacing: 1px; }
  .currentRope { font-size: 12px; margin-top: 6px; font-weight: 600; }
  #modalBackdrop { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.45); z-index: 9999; justify-content: center; align-items: center; overflow-y: auto; animation: fadeInBackdrop 0.3s ease forwards; }
  @keyframes fadeInBackdrop { from {opacity: 0;} to {opacity: 1;} }
  #modalContent { background: white; border-radius: 10px; width: 90vw; max-width: 1200px; max-height: 85vh; margin: 20px; padding: 25px 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); animation: scaleInModal 0.3s ease forwards; display: flex; flex-direction: column; overflow-y: auto; position: relative; }
  @keyframes scaleInModal { from {opacity: 0; transform: scale(0.8);} to {opacity:1; transform: scale(1);} }
  #modalHeader { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
  #modalHeader h3 { margin: 0; font-weight: 700; color: #2542a5; }
  #closeModalBtn { cursor: pointer; background: #203a96; border: none; color: white; font-size: 22px; border-radius: 6px; width: 35px; height: 35px; transition: background-color 0.3s ease; }
  #closeModalBtn:hover { background-color: #506fc5; }
  .actionBtn { margin: 0 3px; padding: 4px 8px; background-color: #3a54d1; color: white; font-weight: bold; border: none; border-radius: 4px; cursor: pointer; user-select: none; transition: background-color 0.3s ease; }
  .actionBtn:hover { background-color: #506fc5; }
  #inputSheetsBtn { margin-top: 10px; padding: 12px; background: #2e7d32; border: none; color: white; font-weight: bold; font-size: 15px; border-radius: 6px; cursor: pointer; transition: background-color 0.3s ease; user-select: none; }
  #inputSheetsBtn:hover:not(:disabled) { background-color: #1b5e20; }
  #inputSheetsBtn:disabled { background-color: #6fbf73; cursor: not-allowed; }

  /* Sliding panel styles */
  #machineSettingsPanel {
    position: absolute;
    top: 60px;
    right: 0;
    width: 350px;
    height: calc(100% - 60px);
    background: #e3ebff;
    border-left: 2px solid #3a54d1;
    box-shadow: -3px 0 10px rgba(58,84,209,0.3);
    padding: 20px;
    overflow-y: auto;
    transform: translateX(100%);
    transition: transform 0.3s ease;
    z-index: 10;
  }
  #machineSettingsPanel.open {
    transform: translateX(0);
  }
  #machineSettingsPanel h4 {
    margin-top: 0;
    color: #203a96;
    font-weight: 700;
    margin-bottom: 15px;
    user-select: none;
  }
  #machineSettingsPanel label {
    font-weight: 600;
    margin-top: 10px;
  }
  #machineSettingsPanel input[type=number], #machineSettingsPanel input[type=text] {
    width: 100%;
    padding: 6px;
    font-size: 14px;
    border-radius: 4px;
    border: 1px solid #304486;
  }
  #machineSettingsPanel .toggleSwitch {
    margin-left: 10px;
    vertical-align: middle;
  }
  #openMachineSettingsBtn {
    margin-left: 10px;
    background: #2542a5;
    padding: 6px 12px;
    font-size: 13px;
    border-radius: 6px;
    border: none;
    color: white;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  #openMachineSettingsBtn:hover {
    background-color: #506fc5;
  }
</style>
</head>
<body>
<div id="app">
  <div id="leftPanel">
    <h2>Add Wire Rope Tag</h2>
    <label for="sizeInput">Size (diameter in mm):</label>
    <input type="number" id="sizeInput" min="0" step="0.01" />
    <label for="lengthInput">Length (ft):</label>
    <input type="number" id="lengthInput" min="0" step="0.01" />
    <label for="bobbinSizeInput">Bobbin Size:</label>
    <input type="text" id="bobbinSizeInput" />
    
    <label for="ropeNumberInput">Rope No.:</label>
    <input type="text" id="ropeNumberInput" />
    
    <button id="lookupConstructionBtn" style="margin-top:6px; padding:7px; background:#3a54d1; color:white; border:none; border-radius:4px; cursor:pointer;">Lookup Construction</button>
    <label for="constructionOutput">Construction:</label>
    <input type="text" id="constructionOutput" readonly />
    
    <label for="coilTypeToggle">Cheese Coil:</label>
    <label class="toggleSwitch">
      <input type="checkbox" id="coilTypeToggle" />
      <span class="slider"></span>
    </label>
    
    <!-- Extended fields -->
    <label for="typeOfStrandInput">Type of Strand:</label>
    <input type="text" id="typeOfStrandInput" />
    <label for="typeOfWireInput">Type of Wire:</label>
    <input type="text" id="typeOfWireInput" />
    <label for="descriptionInput">Description:</label>
    <input type="text" id="descriptionInput" />
    <label for="requiredInput">Required:</label>
    <input type="number" id="requiredInput" min="0" step="any" />
    
    <button id="addEntryBtn">Add Entry</button>
    
    <button id="saveProgramDataBtn" style="background:#2e7d32;">Save Program Data</button>
    <button id="importProgramDataBtn" style="background:#f57c00; margin-left:10px;">Import Saved Program Data</button>
    
    <button id="resetAllBtn">Reset All</button>
    
    <table id="tagTable">
      <thead>
        <tr><th>#</th><th>Size (mm)</th><th>Length (ft)</th><th>Bobbin Size</th><th>Rope No.</th><th>Type</th><th>Strand</th><th>Wire</th><th>Description</th><th>Required</th></tr>
      </thead>
      <tbody></tbody>
    </table>
    <button id="distributeBtn" disabled>Distribute</button>
  </div>
  <div id="mainPanel"></div>
</div>
<div id="processedSection" style="display:none; padding: 0 20px;">
  <h2>Tags Processed</h2>
  <input type="text" id="searchProcessed" placeholder="Search Rope No." />
  <table id="processedTable">
    <thead>
      <tr>
        <th>Size (mm)</th><th>Length (ft)</th><th>Bobbin Size</th><th>Rope No.</th><th>Type</th><th>Strand</th><th>Wire</th><th>Description</th><th>Required</th><th>Actual</th><th>Balance</th><th>Operator</th><th>Machine No.</th><th>Submission Time</th><th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <button id="inputSheetsBtn" disabled>Input to Sheets</button>
</div>

<div id="modalBackdrop" >
  <div id="modalContent" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div id="modalHeader">
      <h3 id="modalTitle">Machine Details</h3>
      <button id="closeModalBtn" aria-label="Close modal">&times;</button>
    </div>
    <button id="openMachineSettingsBtn" title="Toggle Machine Settings">⚙️ Settings</button>
    <table id="queueTableModal">
      <thead>
        <tr>
          <th></th><th>#</th><th>Size (mm)</th><th>Length (ft)</th><th>Bobbin Size</th><th>Rope No.</th><th>Type</th><th>Strand</th><th>Wire</th><th>Description</th><th>Required</th><th>Actual</th><th>Balance</th><th>Operator</th><th>Estimated Finish Time</th><th>Actions</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div id="machineControls" style="margin-top: 10px;">
      <label>Repair Mode:
        <input type="checkbox" id="repairToggle" />
      </label>
      <label style="margin-left:20px;">Gear Shift:
        <select id="gearShiftSelect">
          <option value="1">1 (Slow)</option>
          <option value="2">2</option>
          <option value="3" selected>3</option>
          <option value="4">4 (Fast)</option>
        </select>
      </label>
      <label style="margin-left:20px;">Operator:
        <input type="text" id="modalOperatorInput" placeholder="Enter operator" style="width: 150px;"/>
      </label>
      <div style="margin-top:10px;">
        <strong>Total Estimated Processing Time:</strong> <span id="totalEstimatedTime">0</span> minutes
      </div>
    </div>

    <!-- Sliding panel for machine detailed settings -->
    <div id="machineSettingsPanel" aria-label="Machine detailed settings panel">
      <h4>Machine Detailed Settings</h4>
      <label for="gear1RateInput">Gear 1 Winding Rate (ft/hr):</label>
      <input type="number" min="0" id="gear1RateInput" placeholder="Leave blank or 0 if unknown" />

      <label for="gear2RateInput">Gear 2 Winding Rate (ft/hr):</label>
      <input type="number" min="0" id="gear2RateInput" placeholder="Leave blank or 0 if unknown" />

      <label for="gear3RateInput">Gear 3 Winding Rate (ft/hr):</label>
      <input type="number" min="0" id="gear3RateInput" placeholder="Leave blank or 0 if unknown" />

      <label for="gear4RateInput">Gear 4 Winding Rate (ft/hr):</label>
      <input type="number" min="0" id="gear4RateInput" placeholder="Leave blank or 0 if unknown" />

      <label for="maxBobbinSizeInput">Maximum Bobbin Size Allowed:</label>
      <input type="text" id="maxBobbinSizeInput" placeholder="Leave blank for no limit" />

      <label for="maxWireSizeInput">Maximum Wire Size Allowed (mm):</label>
      <input type="number" min="0" step="0.01" id="maxWireSizeInput" placeholder="Leave blank for no limit" />

      <label for="maxWireLengthInput">Maximum Wire Length Allowed (ft):</label>
      <input type="number" min="0" step="0.01" id="maxWireLengthInput" placeholder="Leave blank for no limit" />

      <label for="canHandleCheeseInput">Able to handle Cheese coils?</label>
      <label class="toggleSwitch" style="display:inline-block; margin-left: 10px;">
        <input type="checkbox" id="canHandleCheeseInput" />
        <span class="slider"></span>
      </label>
    </div>
  </div>
</div>

<script>
  const tags = [];
  const processedTags = [];
  const machines = [];
  const NUM_MACHINES = 13;
  const quotas = {
  "7 x 7": { "CS": 1, "OS": 2, "OW": 6, "KW": 1 },
  "18 x 7": { "6SC": 1, "12SC": 2 },
  "1 x 7": { "OW": 6, "KW": 1 },
  "1 x 19": { "OW": 9, "IW": 9, "KW": 1 },
  "6 x 7": { "OW": 6, "KW": 1 },
  "6 x 15": { "OW": 7, "IW": 7, "KW": 1 },
  "6 x 19": { "OW": 9, "IW": 9, "KW": 1 },
  "6 x 25": { "OW": 12, "FW": 6, "IW": 6, "KW": 1 },
  "6 x 26": { "OW": 10, "SW": 5, "LW": 5, "IW": 5, "KW": 1 },
  "6 x 29": { "OW": 14, "FW": 7, "IW": 7, "KW": 1 },
  "6 x 31": { "OW": 12, "SW": 6, "LW": 6, "IW": 6, "KW": 1 },
  "6 x 36": { "OW": 14, "SW": 7, "LW": 7, "IW": 7, "KW": 1 },
  "6 x 41": { "OW": 16, "SW": 8, "LW": 8, "IW": 8, "KW": 1 },
  "8 x 19": { "OW": 9, "IW": 9, "KW": 1 },
  "8 x 25": { "OW": 12, "FW": 6, "IW": 6, "KW": 1 },
  "8 x 26": { "OW": 10, "SW": 5, "LW": 5, "IW": 5, "KW": 1 },
  "8 x 36": { "OW": 14, "SW": 7, "LW": 7, "IW": 7, "KW": 1 },
  "10 x 26": { "OW": 10, "SW": 5, "LW": 5, "IW": 5, "KW": 1 },
  "17 x 7P": { "OW": 6, "KW": 1 },
  "18 x 7P": { "OW": 6, "KW": 1 },
  "18 x 19": { "OW": 9, "IW": 9, "KW": 1 },
  "35 x 7": { "OW": 6, "KW": 1 },
  "35 x 19": { "OW": 9, "IW": 9, "KW": 1 }
};

  const sizeInput = document.getElementById('sizeInput');
  const lengthInput = document.getElementById('lengthInput');
  const bobbinSizeInput = document.getElementById('bobbinSizeInput');
  const ropeNumberInput = document.getElementById('ropeNumberInput');
  const coilTypeToggle = document.getElementById('coilTypeToggle');
  const typeOfStrandInput = document.getElementById('typeOfStrandInput');
  const typeOfWireInput = document.getElementById('typeOfWireInput');
  const descriptionInput = document.getElementById('descriptionInput');
  const requiredInput = document.getElementById('requiredInput');
  const addEntryBtn = document.getElementById('addEntryBtn');
  const distributeBtn = document.getElementById('distributeBtn');
  const resetAllBtn = document.getElementById('resetAllBtn');
  const tagTableBody = document.querySelector('#tagTable tbody');
  const processedTableBody = document.querySelector('#processedTable tbody');
  const mainPanel = document.getElementById('mainPanel');
  const modalBackdrop = document.getElementById('modalBackdrop');
  const modalCloseBtn = document.getElementById('closeModalBtn');
  const queueTableModalBody = document.querySelector('#queueTableModal tbody');
  const repairToggle = document.getElementById('repairToggle');
  const gearShiftSelect = document.getElementById('gearShiftSelect');
  const totalEstimatedTimeEl = document.getElementById('totalEstimatedTime');
  const modalOperatorInput = document.getElementById('modalOperatorInput');
  const processedSection = document.getElementById('processedSection');
  const searchProcessed = document.getElementById('searchProcessed');
  const inputSheetsBtn = document.getElementById('inputSheetsBtn');
  const openMachineSettingsBtn = document.getElementById('openMachineSettingsBtn');
  const machineSettingsPanel = document.getElementById('machineSettingsPanel');

  // Inputs inside machine settings panel
  const gear1RateInput = document.getElementById('gear1RateInput');
  const gear2RateInput = document.getElementById('gear2RateInput');
  const gear3RateInput = document.getElementById('gear3RateInput');
  const gear4RateInput = document.getElementById('gear4RateInput');
  const maxBobbinSizeInput = document.getElementById('maxBobbinSizeInput');
  const maxWireSizeInput = document.getElementById('maxWireSizeInput');
  const maxWireLengthInput = document.getElementById('maxWireLengthInput');
  const canHandleCheeseInput = document.getElementById('canHandleCheeseInput');

  let currentMachineId = null;
  let machineSettingsOpen = false;

  for(let i=1; i<=NUM_MACHINES; i++) {
    machines.push({
      id:i,
      queue:[],
      repair: false,
      gearShift: 3,
      runningTagIdx: null,
      operator: '',
      runStartTime: null,
      gearRates: {1:null, 2:null, 3:null, 4:null},
      maxBobbinSize: '',
      maxWireSize: null,
      maxWireLength: null,
      canHandleCheese: true
    });
  }

  const GAS_WEBAPP_URL = 'https://script.google.com/macros/s/AKfycbyaR7RoVerzvy30_TJDY4IBAKFtOcI076IO_T9t0btz1r3CF7yjGDU4iPYqSaSg01QE/exec';

  lookupConstructionBtn.addEventListener('click', async () => {
    const ropeNoVal = ropeNumberInput.value.trim();
    if (!ropeNoVal) {
      alert('Please enter a Rope No. first');
      return;
    }
    constructionOutput.value = 'Looking up...';
    try {
      const response = await fetch(GAS_WEBAPP_URL + '?rope=' + encodeURIComponent(ropeNoVal));
      if (response.ok) {
        const text = await response.text();
        constructionOutput.value = text;
      } else {
        constructionOutput.value = 'Error fetching data';
      }
    } catch (err) {
      constructionOutput.value = 'Error: ' + err.message;
    }
  });

saveProgramDataBtn.addEventListener('click', async () => {
  try {
    // Prepare a deep copy to strip out running state
    const cleanMachines = machines.map(({runningTagIdx, runStartTime, ...rest}) => ({...rest}));

    const stateData = {
      tags,
      machines: cleanMachines,  // Save machines without "running" info
      processedTags,
    };

    await fetch(GAS_WEBAPP_URL, {
      method: 'POST',
      body: JSON.stringify(stateData),
      headers: {'Content-Type': 'application/json'},
      mode: 'cors',
    });

    alert('Program data saved successfully!');
  } catch (err) {
    alert('Error saving program data: ' + err.message);
  }
});
importProgramDataBtn.addEventListener('click', async () => {
  if (!confirm('Do you want to import saved program data?')) return;

  try {
    const response = await fetch(GAS_WEBAPP_URL);
    if (!response.ok) throw new Error('Failed to fetch saved data');

    const savedData = await response.json();

    if (!savedData.tags || !savedData.machines || !savedData.processedTags) {
      alert('Saved data appears corrupted or incomplete.');
      return;
    }

    tags.length = 0;
    savedData.tags.forEach(t => tags.push(t));

    machines.length = 0;
    savedData.machines.forEach(m => {
      // Clear running state flags
      m.runningTagIdx = null;
      m.runStartTime = null;
      machines.push(m);
    });

    processedTags.length = 0;
    savedData.processedTags.forEach(pt => processedTags.push(pt));

    renderMachineBlocks();
    renderTagTable();
    renderProcessedTable();

    modalBackdrop.style.display = 'none';

    alert('Import completed successfully!');
    saveAllData();
  } catch (err) {
    alert('Error importing program data: ' + err.message);
  }
});

  function coilTypeToString(isCheese) {
    return isCheese ? 'Cheese Coil' : 'Coil';
  }
  function calculateBalance(required, actual) {
    const balance = required - actual;
    return balance >= 0 ? balance : 0;
  }
  function validateForm() {
    return (
      !isNaN(parseFloat(sizeInput.value)) &&
      !isNaN(parseFloat(lengthInput.value)) &&
      bobbinSizeInput.value.trim() !== '' &&
      ropeNumberInput.value.trim() !== '' &&
      typeOfStrandInput.value.trim() !== '' &&
      typeOfWireInput.value.trim() !== '' &&
      descriptionInput.value.trim() !== '' &&
      !isNaN(parseFloat(requiredInput.value))
    );
  }
  const strandPriorityOrderGeneral = ["CS", "IS", "SS", "LS", "OS"];
const strandPriorityOrderSpecial = ["12SC", "6SC"];
const wirePriorityOrder = ["KW", "IW", "FW", "LS", "SW", "OW"];

function getStrandPriority(strand, construction) {
  if (strandPriorityOrderSpecial.includes(strand)) return strandPriorityOrderSpecial.indexOf(strand);
  if (strandPriorityOrderGeneral.includes(strand)) return strandPriorityOrderGeneral.indexOf(strand);
  return strandPriorityOrderGeneral.length;
}

function getWirePriority(wire) {
  const idx = wirePriorityOrder.indexOf(wire);
  return idx === -1 ? wirePriorityOrder.length : idx;
}

function countExistingTags() {
  const counts = {};
  function incCount(tag) {
    if (!tag.construction) return;
const constructionForKey = tag.construction && tag.construction.trim() !== "" ? tag.construction : tag.description;
const key = `${constructionForKey}|${tag.typeOfStrand}|${tag.typeOfWire}`;

    counts[key] = (counts[key] || 0) + (tag.required || 0);
  }
  machines.forEach(machine => machine.queue.forEach(incCount));
  processedTags.forEach(incCount);
  return counts;
}

function isWithinQuota(tag, counts) {
  if (!tag.construction) return true;
const constructionForKey = tag.construction && tag.construction.trim() !== "" ? tag.construction : tag.description;
const key = `${constructionForKey}|${tag.typeOfStrand}|${tag.typeOfWire}`;

  const quotaForStrandWire = quotas[tag.construction]?.[tag.typeOfStrand];
  if (!quotaForStrandWire) return true;
  const quota = quotaForStrandWire[tag.typeOfWire];
  if (quota === undefined) return true;
  const currentCount = counts[key] || 0;
  return currentCount < quota;
}

function estimateProcessingTime(tag, machine) {
  const gear = machine.gearShift || 3;
  let rate = machine.gearRates[gear];
  if (!rate) rate = 0;
  rate = rate || 10;
  // Multiply by required tag count to reflect multiple tags of same specs
  return ((tag.length * (tag.required || 1)) / rate) * 60; 
}

function tagPriorityCompare(a, b) {
  const counts = countExistingTags();
  const aInQuota = isWithinQuota(a, counts);
  const bInQuota = isWithinQuota(b, counts);
  if (aInQuota && !bInQuota) return -1;
  if (!aInQuota && bInQuota) return 1;

  if (a.construction && b.construction && a.construction !== b.construction) {
    return a.construction.localeCompare(b.construction);
  }

  const hasSpecial = (a.construction && quotas[a.construction] &&
                      ("6SC" in quotas[a.construction] || "12SC" in quotas[a.construction]));
  if (hasSpecial) {
    const strandOrder = ["12SC", "6SC"];
    const aStrandPrio = strandOrder.indexOf(a.typeOfStrand);
    const bStrandPrio = strandOrder.indexOf(b.typeOfStrand);
    if (aStrandPrio !== bStrandPrio) return aStrandPrio - bStrandPrio;
  } else {
    const aStrandPrio = getStrandPriority(a.typeOfStrand, a.construction);
    const bStrandPrio = getStrandPriority(b.typeOfStrand, b.construction);
    if (aStrandPrio !== bStrandPrio) return aStrandPrio - bStrandPrio;
  }

  const aWirePrio = getWirePriority(a.typeOfWire);
  const bWirePrio = getWirePriority(b.typeOfWire);
  if (aWirePrio !== bWirePrio) return aWirePrio - bWirePrio;

  const estA = estimateProcessingTime(a, machines[0]);
  const estB = estimateProcessingTime(b, machines[0]);
  return estB - estA;
}

  function resetForm() {
    sizeInput.value='';
    lengthInput.value='';
    bobbinSizeInput.value='';
    ropeNumberInput.value='';
    coilTypeToggle.checked=false;
    typeOfStrandInput.value='';
    typeOfWireInput.value='';
    descriptionInput.value='';
    requiredInput.value='';
    constructionOutput.value='';
  }
 resetAllBtn.addEventListener('click', () => {
  if (!confirm('Are you sure you want to reset all tags and data? This action cannot be undone.')) return;

  // Clear tags and processed tags
  tags.length = 0;
  processedTags.length = 0;

  // Clear transient machine state but preserve core settings
  machines.forEach(m => {
    m.queue = [];
    m.runningTagIdx = null;
    m.runStartTime = null;
    // Do NOT reset m.repair, m.gearShift, m.canHandleCheese
  });

  renderAll();
  distributeBtn.disabled = true;
  inputSheetsBtn.disabled = processedTags.length === 0;
  saveAllData();
});


  let ropeNoTouched = false, strandTouched = false, wireTouched = false, requiredTouched = false;
  ropeNumberInput.addEventListener('blur', () => { ropeNoTouched = true; tryAutofillRequired(); });
  typeOfStrandInput.addEventListener('blur', () => { strandTouched = true; tryAutofillRequired(); });
  typeOfWireInput.addEventListener('blur', () => { wireTouched = true; tryAutofillRequired(); });
  requiredInput.addEventListener('input', () => { requiredTouched = true; });
  function tryAutofillRequired() {
    if (!(ropeNoTouched && strandTouched && wireTouched)) return;
    if (requiredTouched) return;
    const ropeNo = ropeNumberInput.value.trim().toUpperCase();
    const strand = typeOfStrandInput.value.trim().toUpperCase();
    const wire = typeOfWireInput.value.trim().toUpperCase();
    if (ropeNo ==='' || strand ==='' || wire==='') return;
    let found = null;
    for (const t of tags) {
      if (t.ropeNo.toUpperCase() === ropeNo && t.typeOfStrand.toUpperCase() === strand && t.typeOfWire.toUpperCase() === wire) {
        found = t; break;
      }
    }
    if (!found) {
      for (const m of machines) {
        for (const t of m.queue) {
          if (t.ropeNo.toUpperCase() === ropeNo && t.typeOfStrand.toUpperCase() === strand && t.typeOfWire.toUpperCase() === wire) {
            found = t; break;
          }
        }
        if (found) break;
      }
    }
    if (!found) {
      for (const t of processedTags) {
        if (t.ropeNo.toUpperCase() === ropeNo && t.typeOfStrand.toUpperCase() === strand && t.typeOfWire.toUpperCase() === wire) {
          found = t; break;
        }
      }
    }
    if (found) requiredInput.value = found.required.toFixed(2);
  }
 function renderTagTable() {
  tagTableBody.innerHTML = "";

  // Update header with new columns for Number of tags, Copy, +1
  const thead = tagTableBody.parentElement.querySelector("thead tr");
  thead.innerHTML = `
    <th>#</th>
    <th>Size (mm)</th>
    <th>Length (ft)</th>
    <th>Bobbin Size</th>
    <th>Rope No.</th>
    <th>Coil Type</th>
    <th>Type of Strand</th>
    <th>Type of Wire</th>
    <th>Description</th>
    <th>Required</th>
    <th>Number of Tags</th>
    <th>Copy</th>
    <th>+1</th>
  `;

  tags.forEach((tag, idx) => {
    const tr = document.createElement("tr");

    tr.innerHTML = `
      <td>${idx + 1}</td>
      <td>${tag.size.toFixed(2)}</td>
      <td>${tag.length.toFixed(2)}</td>
      <td>${tag.bobbinSize}</td>
      <td>${tag.ropeNo}</td>
      <td>${coilTypeToString(tag.coilType)}</td>
      <td>${tag.typeOfStrand}</td>
      <td>${tag.typeOfWire}</td>
      <td>${tag.description}</td>
      <td>${tag.required.toFixed(2)}</td>
      <td>${tag.required.toFixed(2)}</td>
      <td><button class="copyBtn" style="padding:4px 8px; font-size:12px;">Copy</button></td>
      <td><button class="plusOneBtn" style="padding:4px 8px; font-size:12px;">+1</button></td>
    `;

    // Copy button event: fill form inputs from row data
    tr.querySelector(".copyBtn").addEventListener("click", () => {
      sizeInput.value = tag.size;
      lengthInput.value = tag.length;
      bobbinSizeInput.value = tag.bobbinSize;
      ropeNumberInput.value = tag.ropeNo;
      coilTypeToggle.checked = tag.coilType;
      typeOfStrandInput.value = tag.typeOfStrand;
      typeOfWireInput.value = tag.typeOfWire;
      descriptionInput.value = tag.description;
      requiredInput.value = tag.required;
    });

    // +1 button event: increment required count and update UI + save
    tr.querySelector(".plusOneBtn").addEventListener("click", () => {
      tag.required += 1;
      tr.querySelector("td:nth-child(10)").textContent = tag.required.toFixed(2); // Required col
      tr.querySelector("td:nth-child(11)").textContent = tag.required.toFixed(2); // Number of tags col
      saveAllData();
    });

    tagTableBody.appendChild(tr);
  });
}

  function renderProcessedTable(filter = '') {
    processedTableBody.innerHTML = '';
    const tagMap = new Map();
    processedTags.forEach(tag => {
      const key = `${tag.ropeNo.toUpperCase()}|${tag.typeOfStrand.toUpperCase()}|${tag.typeOfWire.toUpperCase()}`;
      if (!tagMap.has(key)) {
        tagMap.set(key, { ...tag, actual: tag.actual || 0, count: 1 });
      } else {
        const existing = tagMap.get(key);
        existing.actual += (tag.actual || 0);
        existing.count++;
      }
    });
    let list = Array.from(tagMap.values());
    if (filter) list = list.filter(tag => tag.ropeNo.toUpperCase().includes(filter.toUpperCase()));
    list.forEach((tag, idx) => {
      const tr = document.createElement('tr');
      tr.dataset.index = idx;
      tr.innerHTML = `
        <td>${tag.size.toFixed(2)}</td>
        <td>${tag.length.toFixed(2)}</td>
        <td>${tag.bobbinSize}</td>
        <td>${tag.ropeNo}</td>
        <td>${coilTypeToString(tag.coilType)}</td>
        <td>${tag.typeOfStrand}</td>
        <td>${tag.typeOfWire}</td>
        <td>${tag.description}</td>
        <td>${tag.required.toFixed(2)}</td>
        <td>${tag.actual}</td>
        <td>${tag.balance !== undefined ? tag.balance : ''}</td>
        <td>${tag.operator}</td>
        <td>${tag.machineNumber}</td>
        <td>${tag.submissionTime}</td>
        <td>
          <button class="actionBtn editBtn">Edit</button>
          <button class="actionBtn add1Btn">+1</button>
          <button class="actionBtn add3Btn">+3</button>
        </td>
      `;
      processedTableBody.appendChild(tr);
    });
    attachProcessedTableListeners();
    processedSection.style.display = list.length > 0 ? 'block' : 'none';
    inputSheetsBtn.disabled = processedTags.length === 0;
  }
function attachProcessedTableListeners() {
  processedTableBody.querySelectorAll('tr').forEach(row => {
    const editBtn = row.querySelector('.editBtn');
    const add1Btn = row.querySelector('.add1Btn');
    const add3Btn = row.querySelector('.add3Btn');
    const idx = parseInt(row.dataset.index);
    let isEditing = false;

    editBtn.onclick = () => {
      // Your existing edit toggle logic here
    };

    function updateTagCounts(tag, machineTag, increment) {
      tag.actual = (tag.actual || 0) + increment;
      tag.balance = tag.required - tag.actual;

      if (machineTag) {
        machineTag.actual = tag.actual;
        machineTag.balance = tag.balance;
      }
    }

    add1Btn.onclick = () => {
      const tag = processedTags[idx];
      const machine = machines.find(m => m.id === tag.machineNumber);
      const machineTag = machine?.queue.find(qt =>
        qt.ropeNo === tag.ropeNo &&
        qt.typeOfStrand === tag.typeOfStrand &&
        qt.typeOfWire === tag.typeOfWire &&
        qt.description === tag.description
      );

      updateTagCounts(tag, machineTag, 1);
      updateProcessedRowUI(row, tag);
      renderMachineBlocks();
      saveAllData();
    };

    add3Btn.onclick = () => {
      const tag = processedTags[idx];
      const machine = machines.find(m => m.id === tag.machineNumber);
      const machineTag = machine?.queue.find(qt =>
        qt.ropeNo === tag.ropeNo &&
        qt.typeOfStrand === tag.typeOfStrand &&
        qt.typeOfWire === tag.typeOfWire &&
        qt.description === tag.description
      );

      updateTagCounts(tag, machineTag, 3);
      updateProcessedRowUI(row, tag);
      renderMachineBlocks();
      saveAllData();
    };
  });
}

function updateProcessedRowUI(row, tag) {
  // Adjust these indexes as per your processed tags table column order
  const requiredCellIndex = 8;
  const actualCellIndex = 9;
  const balanceCellIndex = 10;

  row.cells[requiredCellIndex].textContent = tag.required.toFixed(2);
  row.cells[actualCellIndex].textContent = tag.actual.toFixed(2);
  row.cells[balanceCellIndex].textContent = tag.balance.toFixed(2);
}

  addEntryBtn.addEventListener('click', e => {
  e.preventDefault();
  if (!validateForm()) {
    alert('Please fill all fields correctly.');
    return;
  }
  
  tags.push({
    size: parseFloat(sizeInput.value),
    length: parseFloat(lengthInput.value),
    bobbinSize: bobbinSizeInput.value.trim(),
    ropeNo: ropeNumberInput.value.trim(),
    construction: constructionOutput.value.trim(), // add this line
    coilType: coilTypeToggle.checked,
    typeOfStrand: typeOfStrandInput.value.trim(),
    typeOfWire: typeOfWireInput.value.trim(),
    description: descriptionInput.value.trim(),
    required: parseFloat(requiredInput.value),
  });

  renderTagTable();
  distributeBtn.disabled = false;
  resetForm();
  saveAllData();
});


  function colorClassForMachine(machine) {
    if (machine.repair) return 'red';
    if (machine.runningTagIdx !== null) return 'green';
    return 'orange';
  }
  function currentRopeNumber(machine) {
    if (machine.queue.length === 0) return 'No rope';
    return machine.queue[0].ropeNo + (machine.runningTagIdx === 0 ? ' (Running)' : '');
  }
  function renderMachineBlocks() {
    mainPanel.innerHTML = '';
    machines.forEach(machine => {
      const block = document.createElement('div');
      block.className = `machineBlock ${colorClassForMachine(machine)}`;
      block.id = 'machine-' + machine.id;
      block.innerHTML = `
      <div class="machineTitle">Machine ${machine.id}</div>
      <div class="tagCount">${machine.queue.length}</div>
      <div class="currentRope">${currentRopeNumber(machine)}</div>`;
      block.addEventListener('click', () => openMachineModal(machine.id));
      mainPanel.appendChild(block);
    });
  }

  function canProcessTagOnMachine(tag, machine) {
    if (machine.repair) return false;

    if (tag.coilType && !machine.canHandleCheese) return false;

    if (machine.maxBobbinSize) {
      const bobbinLimitNum = parseFloat(machine.maxBobbinSize);
      const tagBobbinNum = parseFloat(tag.bobbinSize);
      if (!isNaN(bobbinLimitNum) && !isNaN(tagBobbinNum)) {
        if (tagBobbinNum > bobbinLimitNum) return false;
      } else {
        if (tag.bobbinSize !== machine.maxBobbinSize) return false;
      }
    }

    if (machine.maxWireSize !== null && machine.maxWireSize !== undefined && !isNaN(machine.maxWireSize)) {
      if (tag.size > parseFloat(machine.maxWireSize)) return false;
    }

    if (machine.maxWireLength !== null && machine.maxWireLength !== undefined && !isNaN(machine.maxWireLength)) {
      if (tag.length > parseFloat(machine.maxWireLength)) return false;
    }

    let maxGearAllowedByWire = 4;
    if (tag.coilType) maxGearAllowedByWire = 2;
    else if (tag.size > 2) maxGearAllowedByWire = 2;
    else if (tag.size >= 1.85 && tag.size <= 1.99) maxGearAllowedByWire = 3;

    if (machine.gearShift > maxGearAllowedByWire) return false;

    return true;
  }

  function estimateProcessingTime(tag, machine) {
    const gear = machine.gearShift || 3;
    let rate = machine.gearRates[gear];
    if (!rate || rate <= 0) rate = 10;

    return (tag.length / rate) * 60;
  }

function distributeTagsLPT() {
  const counts = countExistingTags();
  let allTags = [...tags];
  machines.forEach(machine => {
    allTags = allTags.concat(machine.queue);
    machine.queue = [];
    machine.runningTagIdx = null;
    machine.runStartTime = null;
  });

  allTags.sort(tagPriorityCompare);

  allTags.forEach(tag => {
    const candidates = machines.filter(m => canProcessTagOnMachine(tag, m));
    if (candidates.length === 0) {
      tags.push(tag);
      return;
    }
    let bestMachine = null;
    let bestLoad = Infinity;
    candidates.forEach(machine => {
      const load = machine.queue.reduce((sum, t) => sum + estimateProcessingTime(t, machine), 0);
      const newLoad = load + estimateProcessingTime(tag, machine);
      if (newLoad < bestLoad) {
        bestLoad = newLoad;
        bestMachine = machine;
      }
    });
    if (bestMachine) {
      const assignedTag = {
        ...tag,
        actual: 0,
        balance: tag.required,
        machineNumber: bestMachine.id,
        operator: bestMachine.operator || '',
      };
      bestMachine.queue.push(assignedTag);
const constructionForKey = tag.construction && tag.construction.trim() !== "" ? tag.construction : tag.description;
const key = `${constructionForKey}|${tag.typeOfStrand}|${tag.typeOfWire}`;

counts[key] = (counts[key] || 0) + (tag.actual || 0);
    } else {
      tags.push(tag);
    }
  });

  tags.length = 0;
  renderMachineBlocks();
  renderTagTable();
  resetForm();
  saveAllData();
}


distributeBtn.addEventListener('click', () => {
  if (tags.length === 0) {
    alert('No tags to distribute.');
    return;
  }
  distributeTagsLPT();
  distributeBtn.disabled = true;
  saveAllData();
});


  function openMachineModal(machineId) {
    currentMachineId = machineId;
    const machine = machines.find(m => m.id === machineId);
    if (!machine) return;
    repairToggle.checked = machine.repair;
    gearShiftSelect.value = machine.gearShift || 3;
    modalOperatorInput.value = machine.operator || '';
    loadMachineSettingsToPanel(machine);
    updateGearShiftOptions(machine);
    updateModalQueueTable(machine);
    updateTotalEstimatedProcessingTime(machine);
    hideMachineSettingsPanel();
    modalBackdrop.style.display = 'flex';
  }
  function closeModal() {
    modalBackdrop.style.display = 'none';
    currentMachineId = null;
    hideMachineSettingsPanel();
  }
  modalCloseBtn.addEventListener('click', closeModal);
  modalBackdrop.addEventListener('click', e => {
    if (e.target === modalBackdrop) closeModal();
  });

  repairToggle.addEventListener('change', () => {
    if (currentMachineId === null) return;
    const machine = machines.find(m => m.id === currentMachineId);
    if (!machine) return;
    machine.repair = repairToggle.checked;
    renderMachineBlocks();
    updateTotalEstimatedProcessingTime(machine);
    saveAllData();
  });
  gearShiftSelect.addEventListener('change', () => {
    if (currentMachineId === null) return;
    const machine = machines.find(m => m.id === currentMachineId);
    if (!machine) return;
    machine.gearShift = parseInt(gearShiftSelect.value);
    updateTotalEstimatedProcessingTime(machine);
    saveAllData();
  });
  modalOperatorInput.addEventListener('change', () => {
    if (currentMachineId === null) return;
    const machine = machines.find(m => m.id === currentMachineId);
    if (!machine) return;
    machine.operator = modalOperatorInput.value.trim();
    saveAllData();
  });

  function updateGearShiftOptions(machine) {
    const firstTag = machine.queue[0];
    if (!firstTag) {
      [...gearShiftSelect.options].forEach(opt => opt.disabled = false);
      return;
    }
    const cheeseOnTop = firstTag.coilType;
    const wireSize = firstTag.size;

    [...gearShiftSelect.options].forEach(opt => {
      opt.disabled = false;
      const val = parseInt(opt.value);
      if (cheeseOnTop && val > 2) opt.disabled = true;
      else if (wireSize > 2 && val > 2) opt.disabled = true;
      else if (wireSize >= 1.85 && wireSize <= 1.99 && val > 3) opt.disabled = true;
    });

    if (gearShiftSelect.options[gearShiftSelect.selectedIndex].disabled) {
      const allowedOptions = [...gearShiftSelect.options].filter(o => !o.disabled);
      if (allowedOptions.length > 0) {
        gearShiftSelect.value = allowedOptions[0].value;
        machine.gearShift = parseInt(gearShiftSelect.value);
        saveAllData();
      }
    }
  }

  function updateModalQueueTable(machine) {
    queueTableModalBody.innerHTML = '';
    machine.queue.forEach((tag, idx) => {
      const dragHandle = '<span class="dragHandle" title="Drag to reorder">☰</span>';
      const estFinish = estimateFinishTime(tag, machine, idx);
      let actionBtns = '';
      if (idx === 0) {
        const runBtnText = machine.runningTagIdx === 0 ? 'Stop' : 'Run';
        actionBtns = `<button class="runBtn" data-idx="${idx}">${runBtnText}</button> <button class="finishBtn" data-idx="${idx}">+1 Bobbin</button>
`;
      }
      queueTableModalBody.innerHTML += `
      <tr draggable="true" data-idx="${idx}">
        <td>${dragHandle}</td>
        <td>${idx + 1}</td>
        <td>${tag.size.toFixed(2)}</td>
        <td>${tag.length.toFixed(2)}</td>
        <td>${tag.bobbinSize}</td>
        <td>${tag.ropeNo}</td>
        <td>${coilTypeToString(tag.coilType)}</td>
        <td>${tag.typeOfStrand}</td>
        <td>${tag.typeOfWire}</td>
        <td>${tag.description}</td>
        <td>${tag.required.toFixed(2)}</td>
        <td>${tag.actual || 0}</td>
        <td>${tag.balance || 0}</td>
        <td>${tag.operator || machine.operator || ''}</td>
        <td>${estFinish}</td>
        <td>${actionBtns}</td>
      </tr>`;
    });
    attachModalListeners();
  }

  function attachModalListeners() {
    document.querySelectorAll('.runBtn').forEach(button => {
      button.addEventListener('click', e => {
        if (currentMachineId === null) return;
        const idx = parseInt(e.target.dataset.idx);
        runTagAtIndex(currentMachineId, idx);
      });
    });
    document.querySelectorAll('.finishBtn').forEach(button => {
      button.addEventListener('click', e => {
        if (currentMachineId === null) return;
        const idx = parseInt(e.target.dataset.idx);
        finishTagAtIndex(currentMachineId, idx);
      });
    });
    addDragDropListeners();
  }
  function runTagAtIndex(machineId, idx) {
    const machine = machines.find(m => m.id === machineId);
    if (!machine) return;
    if (machine.runningTagIdx !== null && machine.runningTagIdx !== idx) {
      alert("Only one tag can be running at a time per machine.");
      return;
    }
    if (machine.runningTagIdx === idx) {
      machine.runningTagIdx = null;
      machine.runStartTime = null;
    } else {
      machine.runningTagIdx = idx;
      machine.runStartTime = new Date();
    }
    renderMachineBlocks();
    updateModalQueueTable(machine);
    updateTotalEstimatedProcessingTime(machine);
    saveAllData();
  }
function finishTagAtIndex(machineId, idx) {
  const machine = machines.find(m => m.id === machineId);
  if (!machine) return;
  if (idx !== 0) {
    alert("Only the top tag can be incremented.");
    return;
  }
  const tag = machine.queue[0];
  if (!tag) return;

  // Increment actual count, keep required constant
  tag.actual = (tag.actual || 0) + 1;

  // Calculate balance as required - actual
  tag.balance = (tag.required || 0) - tag.actual;

  // Update or add mirror in processed tags
  const processedIndex = processedTags.findIndex(pt =>
    pt.ropeNo === tag.ropeNo &&
    pt.typeOfStrand === tag.typeOfStrand &&
    pt.typeOfWire === tag.typeOfWire &&
    pt.description === tag.description
  );

  if (processedIndex !== -1) {
    processedTags[processedIndex].actual = tag.actual;
    processedTags[processedIndex].balance = tag.balance;
    processedTags[processedIndex].machineNumber = machine.id;
    processedTags[processedIndex].operator = machine.operator || '';
    processedTags[processedIndex].submissionTime = new Date().toLocaleString();
    processedTags[processedIndex].required = tag.required;  // Keep required constant
  } else {
    const processedTag = {
      ...tag,
      machineNumber: machine.id,
      operator: machine.operator || '',
      submissionTime: new Date().toLocaleString(),
    };
    processedTags.push(processedTag);
  }

  // Remove tag from machine queue once fully processed
  if (tag.actual >= tag.required) {
    machine.queue.shift();
    if (machine.runningTagIdx === 0) {
      machine.runningTagIdx = null;
      machine.runStartTime = null;
    }
  }

  // Refresh UI and save
  renderProcessedTable(searchProcessed.value);
  updateModalQueueTable(machine);
  updateTotalEstimatedProcessingTime(machine);
  renderMachineBlocks();
  saveAllData();
}
  function estimateFinishTime(tag, machine, idx) {
    if (machine.repair) return 'Repair';
    if (machine.runningTagIdx !== 0) return '';
    if (idx !== 0) return '';
    if (!machine.runStartTime) return '';
    const gear = machine.gearShift || 3;
    let rate = machine.gearRates[gear];
    if (!rate || rate <= 0) rate = 10;
    const estHours = tag.length / rate;
    const finishDate = new Date(machine.runStartTime.getTime() + estHours * 3600 * 1000);
    return 'Est. finish: ' + finishDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  function updateTotalEstimatedProcessingTime(machine) {
    if (machine.repair) {
      totalEstimatedTimeEl.textContent = 'N/A (Repair Mode)';
      return;
    }
    let sum = 0;
    machine.queue.forEach(t => {
      const gear = machine.gearShift || 3;
      let rate = machine.gearRates[gear];
      if (!rate || rate <= 0) rate = 10;
      sum += (t.length / rate) * 60;
    });
    totalEstimatedTimeEl.textContent = sum.toFixed(1);
  }

  let draggedRow = null;
  function addDragDropListeners() {
    const rows = queueTableModalBody.querySelectorAll('tr');
    rows.forEach(row => {
      row.addEventListener('dragstart', e => {
        draggedRow = row;
        setTimeout(() => row.style.display = 'none', 0);
      });
      row.addEventListener('dragend', e => {
        draggedRow.style.display = 'table-row';
        draggedRow = null;
      });
      row.addEventListener('dragover', e => e.preventDefault());
      row.addEventListener('dragenter', e => {
        if (e.target.tagName === 'TD' && e.target.parentElement !== draggedRow)
          e.target.parentElement.style.borderTop = '2px solid #3a54d1';
      });
      row.addEventListener('dragleave', e => {
        if (e.target.tagName === 'TD') e.target.parentElement.style.borderTop = '';
      });
      row.addEventListener('drop', e => {
        e.preventDefault();
        if (e.target.tagName === 'TD') {
          e.target.parentElement.style.borderTop = '';
          const fromIndex = parseInt(draggedRow.dataset.idx);
          const toIndex = parseInt(e.target.parentElement.dataset.idx);
          const machine = machines.find(m => m.id === currentMachineId);
          if (!machine) return;
          const [movedTag] = machine.queue.splice(fromIndex, 1);
          machine.queue.splice(toIndex, 0, movedTag);
          if (machine.runningTagIdx === fromIndex) machine.runningTagIdx = toIndex;
          else if (machine.runningTagIdx > fromIndex && machine.runningTagIdx <= toIndex) machine.runningTagIdx--;
          else if (machine.runningTagIdx < fromIndex && machine.runningTagIdx >= toIndex) machine.runningTagIdx++;
          updateModalQueueTable(machine);
          updateTotalEstimatedProcessingTime(machine);
          renderMachineBlocks();
          saveAllData();
        }
      });
    });
  }

  function renderAll() {
    renderTagTable();
    renderProcessedTable();
    renderMachineBlocks();
  }

  function saveAllData() {
    localStorage.setItem('queuedTags', JSON.stringify(machines));
    localStorage.setItem('tags', JSON.stringify(tags));
    localStorage.setItem('processedTags', JSON.stringify(processedTags));
  }

  function loadAllData() {
    const m = localStorage.getItem('queuedTags');
    const t = localStorage.getItem('tags');
    const p = localStorage.getItem('processedTags');
    if (m) {
      const obj = JSON.parse(m);
      if (Array.isArray(obj)) {
        machines.length = 0;
        obj.forEach(val => {
          val.gearRates = val.gearRates || {1:null,2:null,3:null,4:null};
          val.maxBobbinSize = val.maxBobbinSize || '';
          if (val.maxWireSize === undefined) val.maxWireSize = null;
          if (val.maxWireLength === undefined) val.maxWireLength = null;
          if (val.canHandleCheese === undefined) val.canHandleCheese = true;
          machines.push(val);
        });
      }
    }
    if (t) {
      const obj = JSON.parse(t);
      if (Array.isArray(obj)) {
        tags.length = 0;
        obj.forEach(val => tags.push(val));
      }
    }
    if (p) {
      const obj = JSON.parse(p);
      if (Array.isArray(obj)) {
        processedTags.length = 0;
        obj.forEach(val => processedTags.push(val));
      }
    }
  }

  searchProcessed.addEventListener('input', () => {
    renderProcessedTable(searchProcessed.value);
  });

inputSheetsBtn.addEventListener('click', async () => {
  if (processedTags.length === 0) {
    alert("No data to send.");
    return;
  }

  // Your GAS expects JSON with property processedTags as an array
  const payload = {
    processedTags: processedTags.map(tag => ({
      machineNumber: tag.machineNumber,
      ropeNo: tag.ropeNo,
      size: tag.size,
      description: tag.description,
      typeOfStrand: tag.typeOfStrand,
      typeOfWire: tag.typeOfWire,
      required: tag.required,
      actual: tag.actual,
      balance: tag.balance,
      operator: tag.operator,
      submissionTime: tag.submissionTime,
    }))
  };

  try {
    const response = await fetch('https://script.google.com/macros/s/AKfycbz2VJgc7P95InLj7of24Yhzn3sQhulQm7KsDYr_GaUZFrnDaPzEkqMxy9TQMmva_6Ai3w/exec', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      mode: 'cors',
      body: JSON.stringify(payload),
    });

    if (!response.ok) throw new Error('HTTP error ' + response.status);

    const json = await response.json();

    if (json.error) alert('Error from server: ' + json.error);
    else alert('Data sent successfully. Rows inserted: ' + json.rowsInserted);
  } catch (err) {
    alert('Error sending data: ' + err.message);
  }
});



  openMachineSettingsBtn.addEventListener('click', () => {
    machineSettingsOpen ? hideMachineSettingsPanel() : showMachineSettingsPanel();
  });

  function showMachineSettingsPanel() {
    if (!machineSettingsPanel) return;
    machineSettingsPanel.classList.add('open');
    machineSettingsOpen = true;
  }
  function hideMachineSettingsPanel() {
    if (!machineSettingsPanel) return;
    machineSettingsPanel.classList.remove('open');
    machineSettingsOpen = false;
  }

  function loadMachineSettingsToPanel(machine) {
    if (!machine) return;
    gear1RateInput.value = machine.gearRates[1] !== null ? machine.gearRates[1] : '';
    gear2RateInput.value = machine.gearRates[2] !== null ? machine.gearRates[2] : '';
    gear3RateInput.value = machine.gearRates[3] !== null ? machine.gearRates[3] : '';
    gear4RateInput.value = machine.gearRates[4] !== null ? machine.gearRates[4] : '';
    maxBobbinSizeInput.value = machine.maxBobbinSize || '';
    maxWireSizeInput.value = machine.maxWireSize !== null ? machine.maxWireSize : '';
    maxWireLengthInput.value = machine.maxWireLength !== null ? machine.maxWireLength : '';
    canHandleCheeseInput.checked = machine.canHandleCheese !== undefined ? machine.canHandleCheese : true;
  }

  function saveMachineSettingsFromPanel() {
    if (currentMachineId === null) return;
    const machine = machines.find(m => m.id === currentMachineId);
    if (!machine) return;
    const parseNumOrNull = val => val === '' ? null : parseFloat(val);

    machine.gearRates[1] = parseNumOrNull(gear1RateInput.value);
    machine.gearRates[2] = parseNumOrNull(gear2RateInput.value);
    machine.gearRates[3] = parseNumOrNull(gear3RateInput.value);
    machine.gearRates[4] = parseNumOrNull(gear4RateInput.value);
    machine.maxBobbinSize = maxBobbinSizeInput.value.trim();
    machine.maxWireSize = maxWireSizeInput.value === '' ? null : parseFloat(maxWireSizeInput.value);
    machine.maxWireLength = maxWireLengthInput.value === '' ? null : parseFloat(maxWireLengthInput.value);
    machine.canHandleCheese = canHandleCheeseInput.checked;

    updateGearShiftOptions(machine);

    saveAllData();
  }

  [gear1RateInput, gear2RateInput, gear3RateInput, gear4RateInput, maxBobbinSizeInput, maxWireSizeInput, maxWireLengthInput, canHandleCheeseInput].forEach(input => {
    input.addEventListener('change', saveMachineSettingsFromPanel);
  });

  window.addEventListener('load', () => {
    loadAllData();
    renderAll();
    inputSheetsBtn.disabled = processedTags.length === 0;
  });
</script>
</body>

</html>r


